<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="embassy-net-driver-channel"><title>embassy_net_driver_channel - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="embassy_net_driver_channel" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.0-nightly (1ba35e9bb 2024-05-25)" data-channel="nightly" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../embassy_net_driver_channel/index.html">embassy_net_driver_channel</a><span class="version">0.2.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">embassy_net_driver_channel</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/embassy_net_driver_channel/lib.rs.html#1-350">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="embassy-net-driver-channel"><a class="doc-anchor" href="#embassy-net-driver-channel">§</a>embassy-net-driver-channel</h2>
<p>This crate provides a toolkit for implementing <a href="https://crates.io/crates/embassy-net"><code>embassy-net</code></a> drivers in a
higher level way than implementing the <a href="https://crates.io/crates/embassy-net-driver"><code>embassy-net-driver</code></a> trait directly.</p>
<p>The <code>embassy-net-driver</code> trait is polling-based. To implement it, you must write the packet receive/transmit state machines by
hand, and hook up the <code>Waker</code>s provided by <code>embassy-net</code> to the right interrupt handlers so that <code>embassy-net</code>
knows when to poll your driver again to make more progress.</p>
<p>With <code>embassy-net-driver-channel</code> you get a “channel-like” interface instead, where you can send/receive packets
to/from embassy-net. The intended usage is to spawn a “driver task” in the background that does this, passing
packets between the hardware and the channel.</p>
<h3 id="a-note-about-deadlocks"><a class="doc-anchor" href="#a-note-about-deadlocks">§</a>A note about deadlocks</h3>
<p>When implementing a driver using this crate, it might be tempting to write it in the most straightforward way:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">loop </span>{
    <span class="comment">// Wait for either..
    </span><span class="kw">match </span>select(
        <span class="comment">// ... the chip signaling an interrupt, indicating a packet is available to receive, or
        </span>irq_pin.wait_for_low(),
        <span class="comment">// ... a TX buffer becoming available, i.e. embassy-net wants to send a packet
        </span>tx_chan.tx_buf(),
    ).<span class="kw">await </span>{
        Either::First(<span class="kw">_</span>) =&gt; {
            <span class="comment">// a packet is ready to be received!
            </span><span class="kw">let </span>buf = rx_chan.rx_buf().<span class="kw">await</span>; <span class="comment">// allocate a rx buf from the packet queue
            </span><span class="kw">let </span>n = receive_packet_over_spi(buf).<span class="kw">await</span>;
            rx_chan.rx_done(n);
        }
        Either::Second(buf) =&gt; {
            <span class="comment">// a packet is ready to be sent!
            </span>send_packet_over_spi(buf).<span class="kw">await</span>;
            tx_chan.tx_done();
        }
    }
}</code></pre></div>
<p>However, this code has a latent deadlock bug. The symptom is it can hang at <code>rx_chan.rx_buf().await</code> under load.</p>
<p>The reason is that, under load, both the TX and RX queues can get full at the same time. When this happens, the <code>embassy-net</code> task stalls trying to send because the TX queue is full, therefore it stops processing packets in the RX queue. Your driver task also stalls because the RX queue is full, therefore it stops processing packets in the TX queue.</p>
<p>The fix is to make sure to always service the TX queue while you’re waiting for space to become available in the RX queue. For example, select on either “tx_chan.tx_buf() available” or “INT is low AND rx_chan.rx_buf() available”:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">loop </span>{
    <span class="comment">// Wait for either..
    </span><span class="kw">match </span>select(
        <span class="kw">async </span>{
            <span class="comment">// ... the chip signaling an interrupt, indicating a packet is available to receive
            </span>irq_pin.wait_for_low().<span class="kw">await</span>;
            <span class="comment">// *AND* the buffer is ready...
            </span>rx_chan.rx_buf().<span class="kw">await
        </span>},
        <span class="comment">// ... or a TX buffer becoming available, i.e. embassy-net wants to send a packet
        </span>tx_chan.tx_buf(),
    ).<span class="kw">await </span>{
        Either::First(buf) =&gt; {
            <span class="comment">// a packet is ready to be received!
            </span><span class="kw">let </span>n = receive_packet_over_spi(buf).<span class="kw">await</span>;
            rx_chan.rx_done(n);
        }
        Either::Second(buf) =&gt; {
            <span class="comment">// a packet is ready to be sent!
            </span>send_packet_over_spi(buf).<span class="kw">await</span>;
            tx_chan.tx_done();
        }
    }
}</code></pre></div>
<h3 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h3>
<p>These <code>embassy-net</code> drivers are implemented using this crate. You can look at them for inspiration.</p>
<ul>
<li><a href="https://github.com/embassy-rs/embassy/tree/main/cyw43"><code>cyw43</code></a> for WiFi on CYW43xx chips, used in the Raspberry Pi Pico W</li>
<li><a href="https://github.com/embassy-rs/embassy/tree/main/embassy-usb"><code>embassy-usb</code></a> for Ethernet-over-USB (CDC NCM) support.</li>
<li><a href="https://github.com/embassy-rs/embassy/tree/main/embassy-net-wiznet"><code>embassy-net-wiznet</code></a> for Wiznet SPI Ethernet MAC+PHY chips.</li>
<li><a href="https://github.com/embassy-rs/embassy/tree/main/embassy-net-esp-hosted"><code>embassy-net-esp-hosted</code></a> for using ESP32 chips with the <a href="https://github.com/espressif/esp-hosted"><code>esp-hosted</code></a> firmware as WiFi adapters for another non-ESP32 MCU.</li>
</ul>
<h3 id="interoperability"><a class="doc-anchor" href="#interoperability">§</a>Interoperability</h3>
<p>This crate can run on any executor.</p>
<h3 id="license"><a class="doc-anchor" href="#license">§</a>License</h3>
<p>This work is licensed under either of</p>
<ul>
<li>Apache License, Version 2.0 (<a href="LICENSE-APACHE">LICENSE-APACHE</a> or
http://www.apache.org/licenses/LICENSE-2.0)</li>
<li>MIT license (<a href="LICENSE-MIT">LICENSE-MIT</a> or http://opensource.org/licenses/MIT)</li>
</ul>
<p>at your option.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.driver"><code>pub use <a class="mod" href="../embassy_net_driver/index.html" title="mod embassy_net_driver">embassy_net_driver</a> as driver;</code></div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Device.html" title="struct embassy_net_driver_channel::Device">Device</a></div></li><li><div class="item-name"><a class="struct" href="struct.PacketBuf.html" title="struct embassy_net_driver_channel::PacketBuf">PacketBuf</a></div></li><li><div class="item-name"><a class="struct" href="struct.Runner.html" title="struct embassy_net_driver_channel::Runner">Runner</a></div></li><li><div class="item-name"><a class="struct" href="struct.RxRunner.html" title="struct embassy_net_driver_channel::RxRunner">RxRunner</a></div></li><li><div class="item-name"><a class="struct" href="struct.RxToken.html" title="struct embassy_net_driver_channel::RxToken">RxToken</a></div></li><li><div class="item-name"><a class="struct" href="struct.State.html" title="struct embassy_net_driver_channel::State">State</a></div></li><li><div class="item-name"><a class="struct" href="struct.StateRunner.html" title="struct embassy_net_driver_channel::StateRunner">StateRunner</a></div></li><li><div class="item-name"><a class="struct" href="struct.TxRunner.html" title="struct embassy_net_driver_channel::TxRunner">TxRunner</a></div></li><li><div class="item-name"><a class="struct" href="struct.TxToken.html" title="struct embassy_net_driver_channel::TxToken">TxToken</a></div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.new.html" title="fn embassy_net_driver_channel::new">new</a></div></li></ul></section></div></main></body></html>